# src/gui/gui_skeleton.py
"""
===============================
 RECORD MANAGEMENT GUI — FLOW
===============================

This file (gui_skeleton.py) contains the Tkinter-based GUI for the
Travel Agent Record Management System. The GUI does NOT store any data
itself — it delegates all storage and retrieval to two other modules:

1. data_loader.py     → Responsible for loading country & city lists
2. record_manager.py  → Responsible for creating, deleting, updating
                         and saving Client, Flight, and Airline records


---------------------------------------------------------
 HOW THE GUI, DATA_LOADER, AND RECORD_MANAGER CONNECT
---------------------------------------------------------

1) At application startup:

    from data.data_loader import load_country_names, load_city_names
    from record.record_manager import RecordManager

    - load_country_names() loads countries from a text/JSON/CSV file.
    - load_city_names() loads cities from a file.

    These are used to populate dropdown menus in the GUI.

    - RecordManager() is created ONCE when GUI initializes.
      It immediately loads all existing records from disk:
          clients.jsonl
          flights.jsonl
          airlines.jsonl

    The GUI now has:
        self.country_list
        self.city_list
        self.record_manager


---------------------------------------------------------
 HOW THE GUI USES THE RECORD_MANAGER  
---------------------------------------------------------

Important rule:
The GUI NEVER manipulates saved data itself.
It ALWAYS calls a RecordManager method:

• CreateClient()      → For new client records
• UpdateClient()      → For changes
• DeleteClient()      → For deletion
• CreateFlight(), UpdateFlight(), DeleteFlight()
• CreateAirline(), UpdateAirline(), DeleteAirline()

RecordManager does ALL of the following internally:
    - Generate IDs
    - Validate data
    - Append or update dictionaries
    - Convert datetime objects to ISO strings
    - Save the JSONL files using jsonlines
    - Return results back to the GUI


---------------------------------------------------------
 DETAILED EXECUTION TRACE — CREATE CLIENT
---------------------------------------------------------

1. User clicks “Create Client”
   → GUI opens a Toplevel window (form)

2. User fills:
       Name
       Address1
       Address2
       City
       Country
       Phone

3. User presses “Save”
   → GUI collects the inputs into a dictionary

4. GUI calls:
       self.record_manager.CreateClient(
            name=...,
            address1=...,
            address2=...,
            city=...,
            country=...,
            phone=...
       )

5. RecordManager internally:
       - Generates a new Client_ID
       - Creates a dict:
            {
                "Client_ID": N,
                "Name": "...",
                "Address1": "...",
                "Address2": "...",
                "City": "...",
                "Country": "...",
                "Phone": "..."
            }
       - Appends this dict to its in-memory clients list
       - Saves all clients to clients.jsonl
         using jsonlines.Writer()

6. RecordManager returns → GUI

7. GUI:
       - Closes the popup window
       - Calls refresh_client_list()
       - Listbox updates with new client


---------------------------------------------------------
 DETAILED EXECUTION TRACE — CREATE FLIGHT
---------------------------------------------------------

1. User clicks “Create Flight”
   → GUI opens a Toplevel flight form

2. User enters:
       Flight_ID (autogenerated)
       Client_ID
       Airline_ID
       Date
       Starting City
       Destination City

3. User presses “Save”
   → GUI:
       - Parses date into datetime object
       - Ensures Client_ID and Airline_ID are integers

4. GUI calls:
       self.record_manager.CreateFlight(
            client_id = ...,
            airline_id = ...,
            date = datetime object,
            starting_city = ...,
            destination_city = ...
       )

5. RecordManager:
       - Builds flight dict with Date as datetime
       - Appends flight to flights list
       - Saves to flights.jsonl
         (SerializeRecord converts datetime → ISO string)

6. RecordManager returns → GUI

7. GUI:
       - Closes flight popup
       - Calls refresh_flight_list()
       - Flight appears in the listbox


---------------------------------------------------------
 HIGH-LEVEL FLOW SUMMARY
---------------------------------------------------------

 User Action → GUI Form → Validation → RecordManager Method →  
     Update In-Memory Data → Serialize → Write to JSONL → GUI Refresh

This ensures the GUI stays thin and all business logic stays in the
RecordManager.



===============================
 RECORD MANAGEMENT GUI — CODE
===============================
GUI for Travel Agent Record Management System.

This module provides a Tkinter GUI that interacts with:
 - src.record.record_manager.RecordManager
 - src.data.data_loader.load_country_names
 - src.data.data_loader.load_city_names

The GUI collects user input, validates it, converts it to the types
the RecordManager expects (integers, datetime), and calls the
RecordManager CRUD methods. Persistence is handled by RecordManager.
"""

from __future__ import annotations

import os
import sys
from datetime import datetime
from typing import Dict, Iterable, Optional

import tkinter as tk
from tkinter import messagebox, simpledialog, ttk

# Make parent folder (src/) available on sys.path so relative module
# imports work when running from src/ or project root.
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# Local imports after sys.path change
from record.record_manager import RecordManager  # noqa: E402 (import after sys.path update)
from data.data_loader import load_city_names, load_country_names  # noqa: E402


# Helper --------------------------------------------------------------------
def _get_field(record: Dict, *keys: Iterable[str], default: str = "") -> str:
    """
    Robustly fetch the first matching key value from record.

    Many records may use different naming conventions (e.g. "Name" vs "name"
    or "Client_ID" vs "client_id"). This helper checks the provided keys in
    order and returns the first non-None value found. If none found, returns
    the `default`.
    """
    for key in keys:
        if key in record and record[key] is not None:
            return record[key]
    return default


# Main application ---------------------------------------------------------
class RecordManagementSystem(tk.Tk):
    """
    Main Tk application class.

    Responsible for building the UI, collecting and validating input,
    calling methods on RecordManager, and refreshing UI lists.
    """

    def __init__(self) -> None:
        """
        Initialize the main window, data manager, lists and build tabs.
        """
        super().__init__()

        # Instantiate the data manager. It loads existing records from disk.
        self.record_manager = RecordManager()

        # Load country/city lists for comboboxes. Fallback to small lists
        # if loading fails (e.g., missing CSV files).
        try:
            self.country_list = load_country_names()
            self.city_list = load_city_names()
        except Exception:
            # Provide safe defaults to keep GUI usable in development.
            self.country_list = ["United States", "Canada", "United Kingdom"]
            self.city_list = ["New York", "Toronto", "London"]

        # Configure the main window.
        self.title("Travel Agent Record Management System")
        self.geometry("900x600")

        # Notebook (tabbed interface)
        self.notebook = ttk.Notebook(self)
        self.notebook.pack(fill="both", expand=True)

        # Prepare tab frames
        self.client_tab = ttk.Frame(self.notebook)
        self.airline_tab = ttk.Frame(self.notebook)
        self.flight_tab = ttk.Frame(self.notebook)

        # Add tabs to the notebook
        self.notebook.add(self.client_tab, text="Clients")
        self.notebook.add(self.airline_tab, text="Airlines")
        self.notebook.add(self.flight_tab, text="Flights")

        # Build the UI elements for each tab.
        self._build_client_tab()
        self._build_airline_tab()
        self._build_flight_tab()

        # Populate listboxes from the RecordManager's in-memory data.
        self.refresh_client_list()
        self.refresh_airline_list()
        self.refresh_flight_list()

    # ---------------------------------------------------------------------
    # Tab builders
    # ---------------------------------------------------------------------
    def _build_client_tab(self) -> None:
        """Create widgets for the Clients tab."""
        tk.Label(self.client_tab, text="Client Records", font=("Arial", 16)).pack(
            pady=10
        )

        # Horizontal button row
        button_frame = tk.Frame(self.client_tab)
        button_frame.pack(pady=10)

        tk.Button(
            button_frame, text="Create Client", command=self.create_client
        ).grid(row=0, column=0, padx=5)
        tk.Button(
            button_frame, text="Update Client", command=self.update_client
        ).grid(row=0, column=1, padx=5)
        tk.Button(
            button_frame, text="Delete Client", command=self.delete_client
        ).grid(row=0, column=2, padx=5)
        tk.Button(
            button_frame, text="Search Client", command=self.search_client
        ).grid(row=0, column=3, padx=5)

        # Listbox to display clients
        self.client_listbox = tk.Listbox(self.client_tab, width=120)
        self.client_listbox.pack(pady=20)

    def _build_airline_tab(self) -> None:
        """Create widgets for the Airlines tab."""
        tk.Label(self.airline_tab, text="Airline Records", font=("Arial", 16)).pack(
            pady=10
        )

        button_frame = tk.Frame(self.airline_tab)
        button_frame.pack(pady=10)

        tk.Button(
            button_frame, text="Create Airline", command=self.create_airline
        ).grid(row=0, column=0, padx=5)
        tk.Button(
            button_frame, text="Update Airline", command=self.update_airline
        ).grid(row=0, column=1, padx=5)
        tk.Button(
            button_frame, text="Delete Airline", command=self.delete_airline
        ).grid(row=0, column=2, padx=5)
        tk.Button(
            button_frame, text="Search Airline", command=self.search_airline
        ).grid(row=0, column=3, padx=5)

        self.airline_listbox = tk.Listbox(self.airline_tab, width=120)
        self.airline_listbox.pack(pady=20)

    def _build_flight_tab(self) -> None:
        """Create widgets for the Flights tab."""
        tk.Label(self.flight_tab, text="Flight Records", font=("Arial", 16)).pack(
            pady=10
        )

        button_frame = tk.Frame(self.flight_tab)
        button_frame.pack(pady=10)

        tk.Button(
            button_frame, text="Create Flight", command=self.create_flight
        ).grid(row=0, column=0, padx=5)
        tk.Button(
            button_frame, text="Update Flight", command=self.update_flight
        ).grid(row=0, column=1, padx=5)
        tk.Button(
            button_frame, text="Delete Flight", command=self.delete_flight
        ).grid(row=0, column=2, padx=5)
        tk.Button(
            button_frame, text="Search Flight", command=self.search_flight
        ).grid(row=0, column=3, padx=5)

        self.flight_listbox = tk.Listbox(self.flight_tab, width=120)
        self.flight_listbox.pack(pady=20)

    # ---------------------------------------------------------------------
    # Refresh helpers (display current in-memory records)
    # ---------------------------------------------------------------------
    def refresh_client_list(self) -> None:
        """
        Reload clients from RecordManager and show them in the listbox.

        Uses _get_field to be tolerant of naming conventions in the dicts.
        """
        self.client_listbox.delete(0, tk.END)
        clients = self.record_manager.GetAllRecords("Client")
        for rec in clients:
            rec_id = _get_field(rec, "ID", "id")
            name = _get_field(rec, "Name", "name")
            city = _get_field(rec, "City", "city")
            country = _get_field(rec, "Country", "country")
            display = f"{rec_id} - {name} - {city}, {country}"
            self.client_listbox.insert(tk.END, display)

    def refresh_airline_list(self) -> None:
        """Reload airlines from RecordManager and update listbox."""
        self.airline_listbox.delete(0, tk.END)
        airlines = self.record_manager.GetAllRecords("Airline")
        for rec in airlines:
            rec_id = _get_field(rec, "ID", "id")
            company = _get_field(rec, "Company_Name", "company_name", "company")
            display = f"{rec_id} - {company}"
            self.airline_listbox.insert(tk.END, display)

    def refresh_flight_list(self) -> None:
        """Reload flights and format date/time for display if possible."""
        self.flight_listbox.delete(0, tk.END)
        flights = self.record_manager.GetAllRecords("Flight")
        for rec in flights:
            client_id = _get_field(rec, "Client_ID", "client_id")
            airline_id = _get_field(rec, "Airline_ID", "airline_id")
            date_val = _get_field(rec, "Date", "date")
            start_city = _get_field(rec, "Start_City", "start_city")
            end_city = _get_field(rec, "End_City", "end_city")

            # Format date value safely. If it's a datetime, use strftime.
            if isinstance(date_val, datetime):
                date_str = date_val.strftime("%Y-%m-%d %H:%M")
            else:
                date_str = str(date_val)

            display = (
                f"Client {client_id} - Airline {airline_id} - "
                f"{date_str} - {start_city} to {end_city}"
            )
            self.flight_listbox.insert(tk.END, display)

    # ---------------------------------------------------------------------
    # CLIENT CRUD
    # ---------------------------------------------------------------------
    def create_client(self) -> None:
        """Open the client creation form."""
        self._client_form_window(title="Create Client")

    def update_client(self) -> None:
        """Open the client form populated with the selected client's data."""
        sel = self.client_listbox.curselection()
        if not sel:
            messagebox.showerror("Error", "Select a client to update")
            return

        idx = sel[0]
        try:
            record = self.record_manager.GetAllRecords("Client")[idx]
        except IndexError:
            messagebox.showerror("Error", "Selected client not found")
            return

        self._client_form_window(title="Update Client", record=record)

    def _client_form_window(
        self, title: str = "Client Form", record: Optional[Dict] = None
    ) -> None:
        """
        Popup window for creating or updating a client.

        If `record` is provided, pre-fill the fields for editing.
        """
        form = tk.Toplevel(self)
        form.title(title)
        form.geometry("420x520")

        fields = [
            "Name",
            "Address_Line_1",
            "Address_Line_2",
            "Address_Line_3",
            "City",
            "State",
            "Zip_Code",
            "Country",
            "Phone_Number",
        ]
        widgets: Dict[str, tk.Widget] = {}

        for i, field in enumerate(fields):
            label_text = field.replace("_", " ")
            tk.Label(form, text=label_text).grid(
                row=i, column=0, sticky="w", padx=10, pady=6
            )

            # Use combobox for city and country for consistent input.
            if field == "Country":
                combo = ttk.Combobox(form, values=self.country_list, state="readonly")
                combo.grid(row=i, column=1, padx=10, pady=6)
                widgets[field] = combo
            elif field == "City":
                combo = ttk.Combobox(form, values=self.city_list, state="readonly")
                combo.grid(row=i, column=1, padx=10, pady=6)
                widgets[field] = combo
            else:
                entry = tk.Entry(form, width=32)
                entry.grid(row=i, column=1, padx=10, pady=6)
                widgets[field] = entry

        # Pre-fill with existing record values if updating.
        if record:
            for key, widget in widgets.items():
                # Try different key name variants to remain compatible.
                value = _get_field(record, key, key.lower(), key.upper(), "")
                if isinstance(widget, ttk.Combobox):
                    widget.set(value)
                else:
                    widget.insert(0, value)

        # Save button triggers save_client with the form widgets and record.
        tk.Button(
            form,
            text="Save",
            command=lambda: self._save_client(widgets, form, record),
        ).grid(row=len(fields), column=0, columnspan=2, pady=12)

    def _save_client(
        self, widgets: Dict[str, tk.Widget], window: tk.Toplevel, record: Optional[Dict]
    ) -> None:
        """
        Read widget values, validate minimally, and call RecordManager.
        """

        # Extract values from widgets.
        name = widgets["Name"].get()
        address1 = widgets["Address_Line_1"].get()
        address2 = widgets["Address_Line_2"].get()
        address3 = widgets["Address_Line_3"].get()
        city = widgets["City"].get()
        state = widgets["State"].get()
        zip_code = widgets["Zip_Code"].get()
        country = widgets["Country"].get()
        phone = widgets["Phone_Number"].get()

        # Basic validation: ensure name is provided.
        if not name:
            messagebox.showerror("Error", "Name is required")
            return

        if record:
            # Update the existing client. UpdateClient expects certain keys.
            rec_id = record.get("ID") or record.get("id")
            update_fields = {
                "Name": name,
                "Address_Line_1": address1,
                "Address_Line_2": address2,
                "Address_Line_3": address3,
                "City": city,
                "State": state,
                "Zip_Code": zip_code,
                "Country": country,
                "Phone_Number": phone,
            }
            try:
                self.record_manager.UpdateClient(rec_id, **update_fields)
                messagebox.showinfo("Info", "Client updated successfully!")
            except Exception as exc:  # pragma: no cover - show to user
                messagebox.showerror("Error", f"Failed to update client: {exc}")
                return
        else:
            # Create a new client by calling CreateClient with positional args.
            try:
                self.record_manager.CreateClient(
                    name,
                    address1,
                    address2,
                    address3,
                    city,
                    state,
                    zip_code,
                    country,
                    phone,
                )
                messagebox.showinfo("Info", "Client created successfully!")
            except Exception as exc:  # pragma: no cover - show to user
                messagebox.showerror("Error", f"Failed to create client: {exc}")
                return

        # Close popup and refresh the client listbox to reflect the new state.
        window.destroy()
        self.refresh_client_list()

    def delete_client(self) -> None:
        """Delete the selected client using RecordManager.DeleteRecord."""
        sel = self.client_listbox.curselection()
        if not sel:
            messagebox.showerror("Error", "Select a client to delete")
            return

        idx = sel[0]
        try:
            record = self.record_manager.GetAllRecords("Client")[idx]
        except IndexError:
            messagebox.showerror("Error", "Selected client not found")
            return

        rec_id = record.get("ID") or record.get("id")
        if not rec_id:
            messagebox.showerror("Error", "Client has no ID")
            return

        if self.record_manager.DeleteRecord(rec_id, "Client"):
            messagebox.showinfo("Info", "Client deleted successfully!")
            self.refresh_client_list()
        else:
            messagebox.showerror("Error", "Failed to delete client")

    def search_client(self) -> None:
        """Prompt for a search term and show matching clients."""
        term = simpledialog.askstring("Search Client", "Enter search term:")
        if not term:
            return

        results = self.record_manager.SearchRecords(term, "Client")
        self.client_listbox.delete(0, tk.END)
        for rec in results:
            rec_id = _get_field(rec, "ID", "id")
            name = _get_field(rec, "Name", "name")
            city = _get_field(rec, "City", "city")
            country = _get_field(rec, "Country", "country")
            display = f"{rec_id} - {name} - {city}, {country}"
            self.client_listbox.insert(tk.END, display)

    # ---------------------------------------------------------------------
    # AIRLINE CRUD
    # ---------------------------------------------------------------------
    def create_airline(self) -> None:
        """Open the airline creation form."""
        self._airline_form_window(title="Create Airline")

    def update_airline(self) -> None:
        """Open airline form pre-filled with selected airline data."""
        sel = self.airline_listbox.curselection()
        if not sel:
            messagebox.showerror("Error", "Select an airline to update")
            return

        idx = sel[0]
        try:
            record = self.record_manager.GetAllRecords("Airline")[idx]
        except IndexError:
            messagebox.showerror("Error", "Selected airline not found")
            return

        self._airline_form_window(title="Update Airline", record=record)

    def _airline_form_window(
        self, title: str = "Airline Form", record: Optional[Dict] = None
    ) -> None:
        """Popup for creating/updating an airline (single company name field)."""
        form = tk.Toplevel(self)
        form.title(title)
        form.geometry("380x160")

        tk.Label(form, text="Company Name").grid(row=0, column=0, sticky="w", padx=10, pady=10)
        entry = tk.Entry(form, width=40)
        entry.grid(row=0, column=1, padx=10, pady=10)

        if record:
            company = _get_field(record, "Company_Name", "company_name")
            entry.insert(0, company)

        tk.Button(
            form,
            text="Save",
            command=lambda: self._save_airline({"Company_Name": entry}, form, record),
        ).grid(row=1, column=0, columnspan=2, pady=10)

    def _save_airline(
        self, widgets: Dict[str, tk.Widget], window: tk.Toplevel, record: Optional[Dict]
    ) -> None:
        """Persist airline creation or update via RecordManager."""
        company_name = widgets["Company_Name"].get()
        if not company_name:
            messagebox.showerror("Error", "Company name cannot be empty")
            return

        try:
            if record:
                rec_id = record.get("ID") or record.get("id")
                self.record_manager.UpdateAirline(rec_id, company_name)
                messagebox.showinfo("Info", "Airline updated successfully!")
            else:
                self.record_manager.CreateAirline(company_name)
                messagebox.showinfo("Info", "Airline created successfully!")
        except Exception as exc:  # pragma: no cover - show to user
            messagebox.showerror("Error", f"Airline save failed: {exc}")
            return

        window.destroy()
        self.refresh_airline_list()

    def delete_airline(self) -> None:
        """Delete the selected airline using RecordManager.DeleteRecord."""
        sel = self.airline_listbox.curselection()
        if not sel:
            messagebox.showerror("Error", "Select an airline to delete")
            return

        idx = sel[0]
        try:
            record = self.record_manager.GetAllRecords("Airline")[idx]
        except IndexError:
            messagebox.showerror("Error", "Selected airline not found")
            return

        rec_id = record.get("ID") or record.get("id")
        if self.record_manager.DeleteRecord(rec_id, "Airline"):
            messagebox.showinfo("Info", "Airline deleted successfully!")
            self.refresh_airline_list()
        else:
            messagebox.showerror("Error", "Failed to delete airline")

    def search_airline(self) -> None:
        """Prompt the user for a term and display matching airlines."""
        term = simpledialog.askstring("Search Airline", "Enter search term:")
        if not term:
            return

        results = self.record_manager.SearchRecords(term, "Airline")
        self.airline_listbox.delete(0, tk.END)
        for rec in results:
            rec_id = _get_field(rec, "ID", "id")
            company = _get_field(rec, "Company_Name", "company_name")
            self.airline_listbox.insert(tk.END, f"{rec_id} - {company}")

    # ---------------------------------------------------------------------
    # FLIGHT CRUD
    # ---------------------------------------------------------------------
    def create_flight(self) -> None:
        """Open the flight creation form."""
        self._flight_form_window(title="Create Flight")

    def update_flight(self) -> None:
        """Open flight form populated with the selected flight data."""
        sel = self.flight_listbox.curselection()
        if not sel:
            messagebox.showerror("Error", "Select a flight to update")
            return

        idx = sel[0]
        try:
            record = self.record_manager.GetAllRecords("Flight")[idx]
        except IndexError:
            messagebox.showerror("Error", "Selected flight not found")
            return

        self._flight_form_window(title="Update Flight", record=record)

    def _flight_form_window(
        self, title: str = "Flight Form", record: Optional[Dict] = None
    ) -> None:
        """
        Popup for creating/updating a flight.

        Fields:
          - Client_ID (text entry; int validated on save)
          - Airline_ID (text entry; int validated on save)
          - Date (string parsed into datetime)
          - Start_City (combobox)
          - End_City (combobox)
        """
        form = tk.Toplevel(self)
        form.title(title)
        form.geometry("420x300")

        fields = ["Client_ID", "Airline_ID", "Date", "Start_City", "End_City"]
        widgets: Dict[str, tk.Widget] = {}

        for i, field in enumerate(fields):
            tk.Label(form, text=field.replace("_", " ")).grid(
                row=i, column=0, sticky="w", padx=10, pady=6
            )
            if field in ("Start_City", "End_City"):
                combo = ttk.Combobox(form, values=self.city_list, state="readonly")
                combo.grid(row=i, column=1, padx=10, pady=6)
                widgets[field] = combo
            else:
                entry = tk.Entry(form, width=32)
                entry.grid(row=i, column=1, padx=10, pady=6)
                widgets[field] = entry

        # Pre-fill if record provided. Use helper to tolerate key variations.
        if record:
            widgets["Client_ID"].insert(
                0, str(_get_field(record, "Client_ID", "client_id"))
            )
            widgets["Airline_ID"].insert(
                0, str(_get_field(record, "Airline_ID", "airline_id"))
            )

            date_value = _get_field(record, "Date", "date", "")
            if isinstance(date_value, datetime):
                widgets["Date"].insert(0, date_value.strftime("%Y-%m-%d %H:%M"))
            else:
                widgets["Date"].insert(0, str(date_value))

            widgets["Start_City"].set(_get_field(record, "Start_City", "start_city"))
            widgets["End_City"].set(_get_field(record, "End_City", "end_city"))

        tk.Button(
            form,
            text="Save",
            command=lambda: self._save_flight(widgets, form, record),
        ).grid(row=len(fields), column=0, columnspan=2, pady=12)

    def _save_flight(
        self, widgets: Dict[str, tk.Widget], window: tk.Toplevel, record: Optional[Dict]
    ) -> None:
        """
        Validate and save flight data.

        - Validates that client_id and airline_id are integers.
        - Parses date with datetime.fromisoformat (accepts 'YYYY-MM-DD HH:MM'
          and ISO 'YYYY-MM-DDTHH:MM:SS' depending on Python version).
        - Calls RecordManager.CreateFlight or UpdateFlight accordingly.
        """
        # Parse integer IDs
        try:
            client_id = int(widgets["Client_ID"].get())
            airline_id = int(widgets["Airline_ID"].get())
        except ValueError:
            messagebox.showerror("Error", "Client_ID and Airline_ID must be integers")
            return

        date_text = widgets["Date"].get().strip()
        try:
            date_value = datetime.fromisoformat(date_text)
        except ValueError:
            messagebox.showerror(
                "Error",
                "Date must be 'YYYY-MM-DDTHH:MM' or 'YYYY-MM-DD HH:MM'.",
            )
            return

        start_city = widgets["Start_City"].get()
        end_city = widgets["End_City"].get()

        try:
            if record:
                # Update by client_id & airline_id pair.
                update_fields = {"Date": date_value, "Start_City": start_city, "End_City": end_city}
                self.record_manager.UpdateFlight(client_id, airline_id, **update_fields)
                messagebox.showinfo("Info", "Flight updated successfully!")
            else:
                self.record_manager.CreateFlight(client_id, airline_id, date_value, start_city, end_city)
                messagebox.showinfo("Info", "Flight created successfully!")
        except Exception as exc:  # pragma: no cover - runtime error presented to user
            messagebox.showerror("Error", f"Failed to save flight: {exc}")
            return

        window.destroy()
        self.refresh_flight_list()

    def delete_flight(self) -> None:
        """Delete selected flight using its client_id + airline_id pair."""
        sel = self.flight_listbox.curselection()
        if not sel:
            messagebox.showerror("Error", "Select a flight to delete")
            return

        idx = sel[0]
        try:
            record = self.record_manager.GetAllRecords("Flight")[idx]
        except IndexError:
            messagebox.showerror("Error", "Selected flight not found")
            return

        client_id = _get_field(record, "Client_ID", "client_id")
        airline_id = _get_field(record, "Airline_ID", "airline_id")

        try:
            if self.record_manager.DeleteFlight(int(client_id), int(airline_id)):
                messagebox.showinfo("Info", "Flight deleted successfully!")
                self.refresh_flight_list()
            else:
                messagebox.showerror("Error", "Flight not found or could not be deleted")
        except Exception as exc:  # pragma: no cover - show to user
            messagebox.showerror("Error", f"Failed to delete flight: {exc}")

    def search_flight(self) -> None:
        """Prompt for a search term and display matching flights."""
        term = simpledialog.askstring("Search Flight", "Enter search term:")
        if not term:
            return

        results = self.record_manager.SearchRecords(term, "Flight")
        self.flight_listbox.delete(0, tk.END)
        for rec in results:
            client_id = _get_field(rec, "Client_ID", "client_id")
            airline_id = _get_field(rec, "Airline_ID", "airline_id")
            date_val = _get_field(rec, "Date", "date")
            if isinstance(date_val, datetime):
                date_str = date_val.strftime("%Y-%m-%d %H:%M")
            else:
                date_str = str(date_val)
            start_city = _get_field(rec, "Start_City", "start_city")
            end_city = _get_field(rec, "End_City", "end_city")
            display = f"Client {client_id} - Airline {airline_id} - {date_str} - {start_city} to {end_city}"
            self.flight_listbox.insert(tk.END, display)


# Entry point --------------------------------------------------------------
def main() -> None:
    """
    Create and run the GUI. This is provided so callers can import this
    module and call main(), or run the module directly.
    """
    app = RecordManagementSystem()
    app.mainloop()


if __name__ == "__main__":
    main()

